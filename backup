#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_NAME_LENGTH 255

typedef enum { RED, BLACK } Color;

//TODO DARE DIMENSIONE MAX PER I NOMI

//===================================NODI=RICETTE===================
typedef struct IngredientNode {
    char *ingrediente;        // Nome dell'ingrediente
    int quantita;             // Quantità dell'ingrediente
    Color color;              // Colore del nodo (RED o BLACK)
    struct IngredientNode *left, *right, *parent; // Puntatori per l'albero
} IngredientNode;

//===================================NODI=CATALOGO===================
typedef struct {
    char *nome;               //nome ricetta
    IngredientNode *root;     // Radice dell'albero RED-BLACK per ingredienti
    int num_ingredienti;      // Numero di ingredienti nella ricetta
    int activeOrders;
} Ricetta;

typedef struct RecipeNode {
    Ricetta *ricetta;          // Puntatore alla ricetta
    Color color;               // Colore del nodo (RED o BLACK)
    struct RecipeNode *left, *right, *parent; // Puntatori per l'albero
} RecipeNode;

typedef struct {
    RecipeNode *root;  // Radice dell'albero RED-BLACK che gestisce le ricette
    int num_ricette;  // Numero di ricette nel ricettario
} Catalogo;

//===================================NODI=MAGAZZINO===================

// Definizione della struttura per un lotto
typedef struct Lotto {
    int ammount;        // Quantità in grammi
    int scadenza;       // Data di scadenza (time_t per rappresentare il tempo)
    Color color;        // Colore del nodo (RED o BLACK)
    struct Lotto *left, *right, *parent; // Puntatori per l'albero
} Lotto;

// Definizione della struttura per un ingrediente
typedef struct ResourceNode {
    char nome[MAX_NAME_LENGTH];  // Nome dell'ingrediente
    Lotto *lotti;                // Puntatore ai lotti disponibili
    int num_lotti;               // Numero di lotti disponibili
    int maxGrammi;               // Totale degli ingredienti
    Color color;                 // Colore del nodo (RED o BLACK)
    struct ResourceNode *left, *right, *parent; // Puntatori per l'albero
} ResourceNode;

// Definizione della struttura per il magazzino
typedef struct {
    ResourceNode *ingredienti; // Puntatore all'array degli ingredienti nel magazzino
    int num_ingredienti;      // Numero di ingredienti nel magazzino
} Magazzino;

//===================================NODI=ORDINI=======================================

// Definizione del struct Ordine
typedef struct {
    char *nome;           // Puntatore al nome dell'ordine
    int ammount;          // Quantità richiesta dell'ordine
    int peso;             // Peso ordine
    int status;           // 0 preparare, 1 attesa, 3 pronto per la spedizione, 4 spedito
    int arrivalTime;      // Tempo di arrivo dell'ordine
} Ordine;

// Definizione del nodo dell'albero rosso-nero per gestione ordini
typedef struct OrderNode {
    Ordine ordine;              // Dati dell'ordine
    Color color;                 // Colore del nodo (RED o BLACK)
    struct OrderNode *left, *right, *parent; // Puntatori per l'albero
} OrderNode;

typedef struct {
    OrderNode *ordinazioni; // Puntatore all'array degli ingredienti nel magazzino
    int num_ordinazioni_pronte;      // Numero di ordinazioni pronte per la spedizione
} Ordinazioni;

typedef struct {
    Ordine ordine;        // L'ordine stesso
    OrderNode *nodoAlbero; // Puntatore al nodo dell'albero rosso-nero che contiene l'ordine
} OrdineConNodo;
//===================================CORRIERE==========================
//TODO trasformare in un albero?

// Definizione della struttura del corriere
typedef struct {
    int timeCorriere;    //periodicita corriere
    int caricoMax;       //carico massimo corriere
    char **ingredienti;  //Puntatore a un array dinamico dei prodotti contenuti
    int *ammount;        //Puntatore dinamico alle quantità dei prodotti conteuti
    int caricoParziale;   //carcico attuale
} Corriere;

//===================================VARIABILI=GLOBALI==================

//catalogo delle ricette
Catalogo catalogo = {NULL, 0};

//magazino degli ingredienti
Magazzino magazzino = {NULL, 0};

//Ordinazioni del sito
Ordinazioni ordinazioni = {NULL, 0};

//def corriere
Corriere corriere = {0,0,NULL,NULL,0};

//quanti di tempo
int time = 0;

#define BUFFER_SIZE 30000

FILE *file2;

//========================================FUNZIONI===========================================================

//creazione nodo ricette
RecipeNode* createRecipeNode(Ricetta* ricetta) {
    RecipeNode* recipenode = (RecipeNode*)malloc(sizeof(RecipeNode));
    recipenode->ricetta = ricetta;
    recipenode->color = RED;
    recipenode->left = recipenode->right = recipenode->parent = NULL;
    return recipenode;
}

//creazione nodo ingredienti
IngredientNode* createIngredientNode(const char* ingrediente, int quantita) {
    IngredientNode* node = (IngredientNode*)malloc(sizeof(IngredientNode));
    node->ingrediente = strdup(ingrediente); // Duplica la stringa
    node->quantita = quantita;
    node->color = RED;
    node->left = node->right = node->parent = NULL;
    return node;
}

void rotateLeftIngredient(IngredientNode **root, IngredientNode *x) {
    IngredientNode *y = x->right;
    x->right = y->left;

    if (y->left != NULL)
        y->left->parent = x;

    y->parent = x->parent;

    if (x->parent == NULL)
        *root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;

    y->left = x;
    x->parent = y;
}

void rotateRightIngredient(IngredientNode **root, IngredientNode *y) {
    IngredientNode *x = y->left;
    y->left = x->right;

    if (x->right != NULL)
        x->right->parent = y;

    x->parent = y->parent;

    if (y->parent == NULL)
        *root = x;
    else if (y == y->parent->left)
        y->parent->left = x;
    else
        y->parent->right = x;

    x->right = y;
    y->parent = x;
}

void fixViolationIngredient(IngredientNode **root, const IngredientNode *pt) {
    IngredientNode *parent_pt = NULL;
    IngredientNode *grand_parent_pt = NULL;

    while ((pt != *root) && (pt->color != BLACK) && (pt->parent->color == RED)) {
        parent_pt = pt->parent;
        grand_parent_pt = pt->parent->parent;

        if (parent_pt == grand_parent_pt->left) {
            IngredientNode *uncle_pt = grand_parent_pt->right;

            if (uncle_pt != NULL && uncle_pt->color == RED) {
                grand_parent_pt->color = RED;
                parent_pt->color = BLACK;
                uncle_pt->color = BLACK;
                pt = grand_parent_pt;
            } else {
                if (pt == parent_pt->right) {
                    rotateLeftIngredient(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt->parent;
                }

                rotateRightIngredient(root, grand_parent_pt);
                Color tmp = parent_pt->color;
                parent_pt->color = grand_parent_pt->color;
                grand_parent_pt->color = tmp;
                pt = parent_pt;
            }
        } else {
            IngredientNode *uncle_pt = grand_parent_pt->left;

            if (uncle_pt != NULL && uncle_pt->color == RED) {
                grand_parent_pt->color = RED;
                parent_pt->color = BLACK;
                uncle_pt->color = BLACK;
                pt = grand_parent_pt;
            } else {
                if (pt == parent_pt->left) {
                    rotateRightIngredient(root, parent_pt);
                    pt = parent_pt;
                    parent_pt = pt->parent;
                }

                rotateLeftIngredient(root, grand_parent_pt);
                Color tmp = parent_pt->color;
                parent_pt->color = grand_parent_pt->color;
                grand_parent_pt->color = tmp;
                pt = parent_pt;
            }
        }
    }

    (*root)->color = BLACK;
}

//=======================FUNZIONI=GESTIONE=ALBERO=CATALOGO==============================================

// Funzione per effettuare una rotazione a sinistra
void rotateLeft(Catalogo *catalogo, RecipeNode *x) {
    RecipeNode *y = x->right;
    x->right = y->left;
    if (y->left != NULL)
        y->left->parent = x;

    y->parent = x->parent;
    if (x->parent == NULL)
        catalogo->root = y;
    else if (x == x->parent->left)
        x->parent->left = y;
    else
        x->parent->right = y;

    y->left = x;
    x->parent = y;
}

// Funzione per effettuare una rotazione a destra
void rotateRight(Catalogo *catalogo, RecipeNode *y) {
    RecipeNode *x = y->left;
    y->left = x->right;
    if (x->right != NULL)
        x->right->parent = y;

    x->parent = y->parent;
    if (y->parent == NULL)
        catalogo->root = x;
    else if (y == y->parent->left)
        y->parent->left = x;
    else
        y->parent->right = x;

    x->right = y;
    y->parent = x;
}

// Funzione per correggere le violazioni dopo l'inserimento
void fixViolation(Catalogo *catalogo, RecipeNode *z) {
    while (z != catalogo->root && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            RecipeNode *y = z->parent->parent->right;
            if (y != NULL && y->color == RED) {  // Caso 1: lo zio è RED
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {  // Caso 2: lo zio è BLACK e z è figlio destro
                    z = z->parent;
                    rotateLeft(catalogo, z);
                }
                // Caso 3: lo zio è BLACK e z è figlio sinistro
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rotateRight(catalogo, z->parent->parent);
            }
        } else {  // Simmetrico ai casi precedenti
            RecipeNode *y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    rotateRight(catalogo, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rotateLeft(catalogo, z->parent->parent);
            }
        }
    }
    catalogo->root->color = BLACK;  // Assicurarsi che la radice sia sempre nera
}

//===============================RICETTE===========================================

//aggiungi nuovo nodo nell'albero ricette
IngredientNode* BSTInsertIngredient(IngredientNode* root, IngredientNode* pt) {
    if (root == NULL)
        return pt;

    if (strcmp(pt->ingrediente, root->ingrediente) < 0) {
        root->left = BSTInsertIngredient(root->left, pt);
        root->left->parent = root;
    } else if (strcmp(pt->ingrediente, root->ingrediente) > 0) {
        root->right = BSTInsertIngredient(root->right, pt);
        root->right->parent = root;
    }

    return root;
}

//inserisci un nuovo ingrediente nella ricetta
void insertIngredient(Ricetta *ricetta, const char* ingrediente, int quantita) {
    IngredientNode* pt = createIngredientNode(ingrediente, quantita);

    ricetta->root = BSTInsertIngredient(ricetta->root, pt);
    fixViolationIngredient(&ricetta->root, pt);
}

//ricerca ingrediente nella ricetta
IngredientNode* searchIngredientRecipe(IngredientNode* root, const char* ingrediente) {
    if (root == NULL || strcmp(root->ingrediente, ingrediente) == 0)
        return root;

    if (strcmp(ingrediente, root->ingrediente) < 0)
        return searchIngredientRecipe(root->left, ingrediente);

    return searchIngredientRecipe(root->right, ingrediente);
}

//TODO SOSTITUIRE CON FUNZIONE DI RICERCA NODO
//ricerca basata sul nome della ricetta
Ricetta* searchRicetta(RecipeNode* root, const char* nome) {
    // Caso base: l'albero è vuoto o il nome è trovato
    if (root == NULL) {
        return NULL;
    }

    // Confronta il nome cercato con il nome della ricetta nel nodo corrente
    int cmp = strcmp(nome, root->ricetta->nome);

    if (cmp == 0) {
        // Nome trovato
        return root->ricetta;
    } else if (cmp < 0) {
        // Nome cercato è minore, cerca nel sottoalbero sinistro
        return searchRicetta(root->left, nome);
    } else {
        // Nome cercato è maggiore, cerca nel sottoalbero destro
        return searchRicetta(root->right, nome);
    }
}

//==========================FUNZIONI=ALBERO=ORDINI===================================

OrderNode* createOrderNode(Ordine ordine) {
    OrderNode *newNode = (OrderNode *)malloc(sizeof(OrderNode));
    if (newNode == NULL) {
        // Gestione errore allocazione
        return NULL;
    }
    newNode->ordine = ordine;
    newNode->color = RED; // I nuovi nodi sono inizialmente rossi
    newNode->left = newNode->right = newNode->parent = NULL;
    return newNode;
}


void leftRotate(OrderNode **root, OrderNode *x) {
    OrderNode *y = x->right;
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}


void rightRotate(OrderNode **root, OrderNode *y) {
    OrderNode *x = y->left;
    y->left = x->right;
    if (x->right != NULL) {
        x->right->parent = y;
    }
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

void insertFixup(OrderNode **root, OrderNode *z) {
    while (z->parent != NULL && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            OrderNode *y = z->parent->parent->right;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    z = z->parent;
                    leftRotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                rightRotate(root, z->parent->parent);
            }
        } else {
            OrderNode *y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    rightRotate(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                leftRotate(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK;
}

void insertOrder(OrderNode **root, Ordine ordine) {
    OrderNode *z = createOrderNode(ordine);
    if (z == NULL) {
        // Gestione errore creazione nodo
        return;
    }

    OrderNode *y = NULL;
    OrderNode *x = *root;

    // Inserisci il nuovo nodo nell'albero rosso-nero
    while (x != NULL) {
        y = x;
        if (z->ordine.arrivalTime < x->ordine.arrivalTime) {
            x = x->left;
        } else {
            x = x->right;
        }
    }

    z->parent = y;
    if (y == NULL) {
        *root = z; // L'albero era vuoto, z è la nuova radice
    } else if (z->ordine.arrivalTime < y->ordine.arrivalTime) {
        y->left = z;
    } else {
        y->right = z;
    }

    // Azzera i puntatori dei figli e imposta il colore del nuovo nodo a rosso
    z->left = z->right = NULL;
    z->color = RED;

    // Ripristina le proprietà dell'albero rosso-nero dopo l'inserimento
    insertFixup(root, z);
}


// Funzione per trovare il nodo minimo dell'albero a partire da un dato nodo
OrderNode* findMinimum(OrderNode* node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

//Funzione rimozioni ordini spediti
void fixDeletion(OrderNode **root, OrderNode *x) {
    // Assicurati che x non sia NULL
    if (x == NULL) {
        return;
    }

    while (x != *root && x->color == BLACK) {
        if (x == x->parent->left) {
            OrderNode *w = x->parent->right;
            if (w != NULL && w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                leftRotate(root, x->parent);
                w = x->parent->right;
            }
            if ((w == NULL || (w->left == NULL || w->left->color == BLACK)) &&
                (w == NULL || (w->right == NULL || w->right->color == BLACK))) {
                if (w != NULL) {
                    w->color = RED;
                }
                x = x->parent;
            } else {
                if (w != NULL && (w->right == NULL || w->right->color == BLACK)) {
                    if (w->left != NULL) {
                        w->left->color = BLACK;
                    }
                    w->color = RED;
                    rightRotate(root, w);
                    w = x->parent->right;
                }
                if (w != NULL) {
                    w->color = x->parent->color;
                }
                x->parent->color = BLACK;
                if (w != NULL && w->right != NULL) {
                    w->right->color = BLACK;
                }
                leftRotate(root, x->parent);
                x = *root;
            }
        } else {
            OrderNode *w = x->parent->left;
            if (w != NULL && w->color == RED) {
                w->color = BLACK;
                x->parent->color = RED;
                rightRotate(root, x->parent);
                w = x->parent->left;
            }
            if ((w == NULL || (w->right == NULL || w->right->color == BLACK)) &&
                (w == NULL || (w->left == NULL || w->left->color == BLACK))) {
                if (w != NULL) {
                    w->color = RED;
                }
                x = x->parent;
            } else {
                if (w != NULL && (w->left == NULL || w->left->color == BLACK)) {
                    if (w->right != NULL) {
                        w->right->color = BLACK;
                    }
                    w->color = RED;
                    leftRotate(root, w);
                    w = x->parent->left;
                }
                if (w != NULL) {
                    w->color = x->parent->color;
                }
                x->parent->color = BLACK;
                if (w != NULL && w->left != NULL) {
                    w->left->color = BLACK;
                }
                rightRotate(root, x->parent);
                x = *root;
            }
        }
    }
    if (x != NULL) {
        x->color = BLACK;
    }
}



// Funzione per rimuovere un nodo dall'albero rosso-nero
void rbDelete(OrderNode **root, OrderNode *z) {
    OrderNode *y = z;
    OrderNode *x;
    Color originalColor = y->color;

    if (z->left == NULL) {
        x = z->right;
        if (x != NULL) {
            x->parent = z->parent;
        }
        if (z->parent == NULL) {
            *root = x;
        } else if (z == z->parent->left) {
            z->parent->left = x;
        } else {
            z->parent->right = x;
        }
    } else if (z->right == NULL) {
        x = z->left;
        if (x != NULL) {
            x->parent = z->parent;
        }
        if (z->parent == NULL) {
            *root = x;
        } else if (z == z->parent->left) {
            z->parent->left = x;
        } else {
            z->parent->right = x;
        }
    } else {
        y = findMinimum(z->right);
        originalColor = y->color;
        x = y->right;
        if (y->parent == z) {
            if (x != NULL) {
                x->parent = y;
            }
        } else {
            if (x != NULL) {
                x->parent = y->parent;
            }
            y->parent->left = x;
            y->right = z->right;
            z->right->parent = y;
        }
        y->parent = z->parent;
        if (z->parent == NULL) {
            *root = y;
        } else if (z == z->parent->left) {
            z->parent->left = y;
        } else {
            z->parent->right = y;
        }
        y->left = z->left;
        z->left->parent = y;
        y->color = z->color;
    }

    free(z);

    if (originalColor == BLACK) {
        fixDeletion(root, x);
    }
}

// Funzione ricorsiva per attraversare l'albero e rimuovere i nodi con status = 4
void removeOrdersWithStatus4(OrderNode **root, OrderNode *node) {
    if (node == NULL) {
        return;
    }

    removeOrdersWithStatus4(root, node->left);
    removeOrdersWithStatus4(root, node->right);

    if (node->ordine.status == 4) {
        rbDelete(root, node);
    }
}

// Funzione principale per avviare la rimozione
void rimuoviOrdini(Ordinazioni *ordinazioni) {
    removeOrdersWithStatus4(&(ordinazioni->ordinazioni), ordinazioni->ordinazioni);
}

//==========================NUOVA=RICETTA=========================
void insertRicetta(RecipeNode **root, Ricetta *ricetta) {
    RecipeNode *pt = createRecipeNode(ricetta);

    // Esegui l'inserimento nel BST
    RecipeNode *y = NULL;
    RecipeNode *x = *root;

    while (x != NULL) {
        y = x;
        if (strcmp(pt->ricetta->nome, x->ricetta->nome) < 0)
            x = x->left;
        else
            x = x->right;
    }

    pt->parent = y;

    if (y == NULL) {
        // L'albero era vuoto
        *root = pt;
    } else if (strcmp(pt->ricetta->nome, y->ricetta->nome) < 0) {
        y->left = pt;
    } else {
        y->right = pt;
    }

    // Correggi le violazioni dell'albero RED-BLACK
    fixViolation(&catalogo, pt);
    catalogo.num_ricette++;
}

//========================RIMUOVI=RICETTA============================

// Funzione ausiliaria per sostituire un sottoalbero con un altro
void rbTransplant(Catalogo *catalogo, RecipeNode *u, RecipeNode *v) {
    if (u->parent == NULL) {
        catalogo->root = v;
    } else if (u == u->parent->left) {
        u->parent->left = v;
    } else {
        u->parent->right = v;
    }
    if (v != NULL) {
        v->parent = u->parent;
    }
}

// Trova il nodo con il valore minimo a partire da un dato nodo
RecipeNode *minimum(RecipeNode *node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

// Funzione per il bilanciamento dell'albero dopo la rimozione
void rbDeleteFixup(Catalogo *catalogo, RecipeNode *x) {
    while (x != catalogo->root && (x == NULL || x->color == BLACK)) {
        if (x != NULL && x->parent != NULL) {
            if (x == x->parent->left) {
                RecipeNode *w = x->parent->right;
                if (w != NULL && w->color == RED) {
                    w->color = BLACK;
                    x->parent->color = RED;
                    rotateLeft(catalogo, x->parent);
                    w = x->parent->right;
                }
                if ((w == NULL || (w->left == NULL || w->left->color == BLACK)) &&
                    (w == NULL || (w->right == NULL || w->right->color == BLACK))) {
                    if (w != NULL) {
                        w->color = RED;
                    }
                    x = x->parent;
                } else {
                    if (w->right == NULL || w->right->color == BLACK) {
                        if (w->left != NULL) {
                            w->left->color = BLACK;
                        }
                        w->color = RED;
                        rotateRight(catalogo, w);
                        w = x->parent->right;
                    }
                    if (w != NULL) {
                        w->color = x->parent->color;
                        x->parent->color = BLACK;
                        if (w->right != NULL) {
                            w->right->color = BLACK;
                        }
                        rotateLeft(catalogo, x->parent);
                    }
                    x = catalogo->root;
                }
            } else { // Speculare per il caso x == x->parent->right
                RecipeNode *w = x->parent->left;
                if (w != NULL && w->color == RED) {
                    w->color = BLACK;
                    x->parent->color = RED;
                    rotateRight(catalogo, x->parent);
                    w = x->parent->left;
                }
                if ((w == NULL || (w->right == NULL || w->right->color == BLACK)) &&
                    (w == NULL || (w->left == NULL || w->left->color == BLACK))) {
                    if (w != NULL) {
                        w->color = RED;
                    }
                    x = x->parent;
                } else {
                    if (w->left == NULL || w->left->color == BLACK) {
                        if (w->right != NULL) {
                            w->right->color = BLACK;
                        }
                        w->color = RED;
                        rotateLeft(catalogo, w);
                        w = x->parent->left;
                    }
                    if (w != NULL) {
                        w->color = x->parent->color;
                        x->parent->color = BLACK;
                        if (w->left != NULL) {
                            w->left->color = BLACK;
                        }
                        rotateRight(catalogo, x->parent);
                    }
                    x = catalogo->root;
                }
            }
        } else {
            break; // Evita il segmentation fault uscendo dal ciclo se x o x->parent è NULL
        }
    }
    if (x != NULL) {
        x->color = BLACK;
    }
}



// Funzione di ricerca del nodo della ricetta
RecipeNode *searchRecipeNode(RecipeNode *root, const char *nome_ricetta) {
    if (root == NULL || strcmp(nome_ricetta, root->ricetta->nome) == 0) {
        return root;
    }

    if (strcmp(nome_ricetta, root->ricetta->nome) < 0) {
        return searchRecipeNode(root->left, nome_ricetta);
    } else {
        return searchRecipeNode(root->right, nome_ricetta);
    }
}

void rimuoviRicetta(const Ricetta *recipeToKill) {
    if (recipeToKill == NULL) {
        return;
    }

    // Trova il nodo della ricetta nel catalogo
    RecipeNode *z = searchRecipeNode(catalogo.root, recipeToKill->nome);

    if (z == NULL) {
        return; // La ricetta non è presente
    }

    RecipeNode *y = z;
    RecipeNode *x;
    Color yOriginalColor = y->color;

    if (z->left == NULL) {
        x = z->right;
        rbTransplant(&catalogo, z, z->right);
    } else if (z->right == NULL) {
        x = z->left;
        rbTransplant(&catalogo, z, z->left);
    } else {
        y = minimum(z->right);
        yOriginalColor = y->color;
        x = y->right;

        if (y->parent == z) {
            if (x != NULL) {
                x->parent = y;
            }
        } else {
            rbTransplant(&catalogo, y, y->right);
            y->right = z->right;
            y->right->parent = y;
        }

        rbTransplant(&catalogo, z, y);
        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }

    free(z->ricetta->nome);
    free(z->ricetta);
    free(z);

    if (yOriginalColor == BLACK) {
        rbDeleteFixup(&catalogo, x);
    }

    catalogo.num_ricette--;
}
//=============================RIFORNIMENTO=MAGAZZINO=================================

void ruotaSinistra(ResourceNode **root, ResourceNode *x) {
    ResourceNode *y = x->right;
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}

void ruotaDestra(ResourceNode **root, ResourceNode *y) {
    ResourceNode *x = y->left;
    y->left = x->right;
    if (x->right != NULL) {
        x->right->parent = y;
    }
    x->parent = y->parent;
    if (y->parent == NULL) {
        *root = x;
    } else if (y == y->parent->right) {
        y->parent->right = x;
    } else {
        y->parent->left = x;
    }
    x->right = y;
    y->parent = x;
}

void correggiViolazioni(ResourceNode **root, ResourceNode *z) {
    while (z != *root && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            ResourceNode *y = z->parent->parent->right; // Zio
            if (y != NULL && y->color == RED) {
                // Caso 1: lo zio è rosso
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    // Caso 2: lo zio è nero e z è un figlio destro
                    z = z->parent;
                    ruotaSinistra(root, z);
                }
                // Caso 3: lo zio è nero e z è un figlio sinistro
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                ruotaDestra(root, z->parent->parent);
            }
        } else {
            // Caso simmetrico
            ResourceNode *y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    ruotaDestra(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                ruotaSinistra(root, z->parent->parent);
            }
        }
    }
    (*root)->color = BLACK;
}

ResourceNode* creaNuovoIngrediente(char *nome_ingrediente, int ammount, int scadenza) {
    ResourceNode *nuovoIngrediente = (ResourceNode*)malloc(sizeof(ResourceNode));
    strcpy(nuovoIngrediente->nome, nome_ingrediente);
    nuovoIngrediente->num_lotti = 1;
    nuovoIngrediente->maxGrammi = ammount;
    nuovoIngrediente->color = RED;  // Nuovo nodo sempre rosso
    nuovoIngrediente->left = nuovoIngrediente->right = nuovoIngrediente->parent = NULL;

    Lotto *new_lotto = (Lotto*)malloc(sizeof(Lotto));
    new_lotto->ammount = ammount;
    new_lotto->scadenza = scadenza;
    new_lotto->color = BLACK;  // Consideriamo i lotti come nodi foglia neri
    new_lotto->left = new_lotto->right = new_lotto->parent = NULL;
    nuovoIngrediente->lotti = new_lotto;

    return nuovoIngrediente;
}

// Funzione di ricerca per trovare un ingrediente specifico nel magazzino
ResourceNode* searchIngredientMagazzino(ResourceNode *nodo, const char *nome) {
    if (nodo == NULL) {
        return NULL;  // Ingrediente non trovato
    }

    const int cmp = strcmp(nome, nodo->nome);

    if (cmp == 0) {
        return nodo;  // Ingrediente trovato
    } else if (cmp < 0) {
        return searchIngredientMagazzino(nodo->left, nome);  // Cerca a sinistra
    } else {
        return searchIngredientMagazzino(nodo->right, nome); // Cerca a destra
    }
}



void ruotaSinistraLotto(Lotto **root, Lotto *x) {
    Lotto *y = x->right;
    x->right = y->left;
    if (y->left != NULL) {
        y->left->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->left) {
        x->parent->left = y;
    } else {
        x->parent->right = y;
    }
    y->left = x;
    x->parent = y;
}

void ruotaDestraLotto(Lotto **root, Lotto *x) {
    Lotto *y = x->left;
    x->left = y->right;
    if (y->right != NULL) {
        y->right->parent = x;
    }
    y->parent = x->parent;
    if (x->parent == NULL) {
        *root = y;
    } else if (x == x->parent->right) {
        x->parent->right = y;
    } else {
        x->parent->left = y;
    }
    y->right = x;
    x->parent = y;
}

void correggiViolazioniLotto(Lotto **root, Lotto *z) {
    while (z != NULL && z != *root && z->parent->color == RED) {
        if (z->parent == z->parent->parent->left) {
            Lotto *y = z->parent->parent->right;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->right) {
                    z = z->parent;
                    ruotaSinistraLotto(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                ruotaDestraLotto(root, z->parent->parent);
            }
        } else {
            Lotto *y = z->parent->parent->left;
            if (y != NULL && y->color == RED) {
                z->parent->color = BLACK;
                y->color = BLACK;
                z->parent->parent->color = RED;
                z = z->parent->parent;
            } else {
                if (z == z->parent->left) {
                    z = z->parent;
                    ruotaDestraLotto(root, z);
                }
                z->parent->color = BLACK;
                z->parent->parent->color = RED;
                ruotaSinistraLotto(root, z->parent->parent);
            }
        }
    }
    if (*root != NULL) {
        (*root)->color = BLACK;
    }
}

void aggiungiIngredienteMagazzino(Magazzino *magazzino, char *nome_ingrediente, const int ammount, const int scadenza) {
    ResourceNode *y = NULL;
    ResourceNode *x = magazzino->ingredienti;

    // Cerca l'ingrediente nell'albero
    while (x != NULL) {
        y = x;
        int cmp = strcmp(nome_ingrediente, x->nome);

        if (cmp == 0) {
            // Ingrediente trovato, aggiungi lotto
            Lotto *new_lotto = (Lotto*)malloc(sizeof(Lotto));
            new_lotto->ammount = ammount;
            new_lotto->scadenza = scadenza;
            new_lotto->color = RED;  // Nuovo lotto inserito come rosso
            new_lotto->left = new_lotto->right = new_lotto->parent = NULL;

            // Inserisci il lotto nell'albero dei lotti (rispettando l'ordine di scadenza)
            Lotto *lotto_current = x->lotti;
            Lotto *lotto_parent = NULL;

            while (lotto_current != NULL) {
                lotto_parent = lotto_current;

                if (scadenza < lotto_current->scadenza) {
                    lotto_current = lotto_current->left;
                } else {
                    lotto_current = lotto_current->right;
                }
            }

            new_lotto->parent = lotto_parent;
            if (lotto_parent == NULL) {
                x->lotti = new_lotto;
            } else if (scadenza < lotto_parent->scadenza) {
                lotto_parent->left = new_lotto;
            } else {
                lotto_parent->right = new_lotto;
            }

            // Correggi eventuali violazioni dell'albero rosso-nero
            correggiViolazioniLotto(&(x->lotti), new_lotto);
            x->num_lotti++;
            x->maxGrammi += ammount;
            return;
        } else if (cmp < 0) {
            x = x->left;
        } else {
            x = x->right;
        }
    }

    // Ingrediente non trovato, creiamo un nuovo nodo
    ResourceNode *z = creaNuovoIngrediente(nome_ingrediente, ammount, scadenza);
    z->parent = y;

    if (y == NULL) {
        magazzino->ingredienti = z;
    } else if (strcmp(z->nome, y->nome) < 0) {
        y->left = z;
    } else {
        y->right = z;
    }

    // Correggi eventuali violazioni dell'albero rosso-nero per l'ingrediente
    correggiViolazioni(&(magazzino->ingredienti), z);
    magazzino->num_ingredienti++;
}


void riparaAlberoMagazzinoRM(Lotto **root, Lotto *x) {
    while (x != NULL && x != *root && x->parent->color == RED) {
        if (x->parent == x->parent->parent->left) {
            Lotto *y = x->parent->parent->right;
            if (y != NULL && y->color == RED) {
                x->parent->color = BLACK;
                y->color = BLACK;
                x->parent->parent->color = RED;
                x = x->parent->parent;
            } else {
                if (x == x->parent->right) {
                    x = x->parent;
                    ruotaSinistraLotto(root, x);
                }
                x->parent->color = BLACK;
                x->parent->parent->color = RED;
                ruotaDestraLotto(root, x->parent->parent);
            }
        } else {
            Lotto *y = x->parent->parent->left;
            if (y != NULL && y->color == RED) {
                x->parent->color = BLACK;
                y->color = BLACK;
                x->parent->parent->color = RED;
                x = x->parent->parent;
            } else {
                if (x == x->parent->left) {
                    x = x->parent;
                    ruotaDestraLotto(root, x);
                }
                x->parent->color = BLACK;
                x->parent->parent->color = RED;
                ruotaSinistraLotto(root, x->parent->parent);
            }
        }
    }
    if (*root != NULL) {
        (*root)->color = BLACK;
    }
}



Lotto *trovaMinimo(Lotto *node) {
    while (node->left != NULL) {
        node = node->left;
    }
    return node;
}

void trapianta(Lotto **root, Lotto *u, Lotto *v) {
    if (u->parent == NULL) {
        *root = v;
    } else if (u == u->parent->left) {
        u->parent->left = v;
    } else {
        u->parent->right = v;
    }
    if (v != NULL) {
        v->parent = u->parent;
    }
}

void rimuoviLotto(Lotto **root, Lotto *z) {
    Lotto *y = z;
    Lotto *x;
    Color yOriginalColor = y->color;

    if (z->left == NULL) {
        x = z->right;
        trapianta(root, z, z->right);
    } else if (z->right == NULL) {
        x = z->left;
        trapianta(root, z, z->left);
    } else {
        y = trovaMinimo(z->right);
        yOriginalColor = y->color;
        x = y->right;
        if (y->parent == z) {
            if (x != NULL) {
                x->parent = y;
            }
        } else {
            trapianta(root, y, y->right);
            y->right = z->right;
            y->right->parent = y;
        }
        trapianta(root, z, y);
        y->left = z->left;
        y->left->parent = y;
        y->color = z->color;
    }
    if (yOriginalColor == BLACK) {
        riparaAlberoMagazzinoRM(root, x);
    }
    free(z);
}

//============================PREPARA=ORDINI===================
// Funzione ricorsiva per sommare il peso degli ingredienti nell'albero
int sommaPesoIngredienti(IngredientNode *nodo) {
    if (nodo == NULL) {
        return 0;
    }

    // Somma il peso corrente con il peso dei nodi figli (sinistro e destro)
    int peso_sinistro = sommaPesoIngredienti(nodo->left);
    int peso_destro = sommaPesoIngredienti(nodo->right);

    // Somma la quantità dell'ingrediente corrente con il peso dei figli
    return nodo->quantita + peso_sinistro + peso_destro;
}

// Funzione per calcolare il peso totale della ricetta
int calcolaPeso(const Ricetta *ricetta) {
    // Se la radice dell'albero è NULL, non ci sono ingredienti
    if (ricetta->root == NULL) {
        return 0;
    }

    // Chiama la funzione ricorsiva per sommare il peso degli ingredienti
    return sommaPesoIngredienti(ricetta->root);
}

void verificaScadenzaLotti(Lotto **root, ResourceNode *ingredienteMagazzino, int time, int *trovatoScaduto, int *trovatoNonScaduto) {
    if (*root == NULL || *trovatoScaduto || *trovatoNonScaduto) {
        return;
    }

    // Controlla prima il sottoalbero sinistro
    verificaScadenzaLotti(&(*root)->left, ingredienteMagazzino, time, trovatoScaduto, trovatoNonScaduto);

    if (*trovatoScaduto || *trovatoNonScaduto) {
        return;
    }

    // Controllo del nodo corrente
    if ((*root)->scadenza <= time) {
        Lotto *nodoDaRimuovere = *root;

        // Decrementa il numero di lotti disponibili
        ingredienteMagazzino->num_lotti--;

        // Aggiorna il totale di grammi disponibili per l'ingrediente
        ingredienteMagazzino->maxGrammi -= nodoDaRimuovere->ammount;

        // Rimuove il lotto scaduto
        rimuoviLotto(root, nodoDaRimuovere);

        *trovatoScaduto = 1;
        return;
    }

    if ((*root)->scadenza > time) {
        *trovatoNonScaduto = 1;
        return;
    }

    // Controlla il sottoalbero destro
    verificaScadenzaLotti(&(*root)->right, ingredienteMagazzino, time, trovatoScaduto, trovatoNonScaduto);
}

void verificaScadenza(ResourceNode *resource_node, int time) {
    if (resource_node == NULL) {
        return;
    }

    int trovatoScaduto = 0;
    int trovatoNonScaduto = 0;

    do {
        trovatoScaduto = 0;
        trovatoNonScaduto = 0;
        verificaScadenzaLotti(&(resource_node->lotti), resource_node, time, &trovatoScaduto, &trovatoNonScaduto);
    } while (trovatoScaduto);

    if (!trovatoScaduto) {
        verificaScadenza(resource_node->left, time);
        verificaScadenza(resource_node->right, time);
    }
}


void verificaQuantitaLotti(Lotto **root, ResourceNode *ingredienteMagazzino, int *trovatoEsaurito, int *trovatoNonVuoto) {
    if (*root == NULL || *trovatoEsaurito || *trovatoNonVuoto) {
        return;
    }

    // Controlla prima il sottoalbero sinistro
    verificaQuantitaLotti(&(*root)->left, ingredienteMagazzino, trovatoEsaurito, trovatoNonVuoto);

    // Se un lotto esaurito o non vuoto è stato trovato, termina la ricerca
    if (*trovatoEsaurito || *trovatoNonVuoto) {
        return;
    }

    // Controllo del nodo corrente
    if ((*root)->ammount == 0) {
        Lotto *nodoDaRimuovere = *root;

        // Rimuove il lotto esaurito
        rimuoviLotto(root, nodoDaRimuovere);

        // Decrementa il numero di lotti disponibili
        ingredienteMagazzino->num_lotti--;

        // Lotto esaurito trovato, si può terminare la ricerca per questo ingrediente
        *trovatoEsaurito = 1;
        return;
    } else if ((*root)->ammount > 0) {
        // Lotto non vuoto trovato, si può terminare la ricerca per questo ingrediente
        *trovatoNonVuoto = 1;
        return;
    }

    // Se non è stato trovato un lotto esaurito o non vuoto, controlla il sottoalbero destro
    verificaQuantitaLotti(&(*root)->right, ingredienteMagazzino, trovatoEsaurito, trovatoNonVuoto);
}


void verificaQuantita(ResourceNode *resource_node) {
    if (resource_node == NULL) {
        return;
    }

    int trovatoEsaurito = 0;
    int trovatoNonVuoto = 0;
    verificaQuantitaLotti(&(resource_node->lotti), resource_node, &trovatoEsaurito, &trovatoNonVuoto);

    // Procedi solo se non hai trovato un lotto esaurito per questo ingrediente
    if (!trovatoEsaurito) {
        verificaQuantita(resource_node->left);
        verificaQuantita(resource_node->right);
    }
}




bool verificaIngrediente(IngredientNode *nodoIngrediente, Ricetta *associatedRecipe, int ammount) {
    if (nodoIngrediente == NULL) {
        return true;  // Raggiunto un ramo vuoto, nessun problema
    }

    IngredientNode *ingredienteRicetta = searchIngredientRecipe(associatedRecipe->root, nodoIngrediente->ingrediente);

    if (ingredienteRicetta == NULL) {
        printf("Errore: Ingrediente %s non trovato nella ricetta.\n", nodoIngrediente->ingrediente);
        return false;
    }

    const int grammiRichiesti = ingredienteRicetta->quantita * ammount;

    ResourceNode *ingredienteMagazzino = searchIngredientMagazzino(magazzino.ingredienti, ingredienteRicetta->ingrediente);

    if (ingredienteMagazzino == NULL) {
        //printf("Ingrediente %s non trovato nel magazzino!\n", nodoIngrediente->ingrediente);
        return false; // Non fattibile
    }

    if (grammiRichiesti > ingredienteMagazzino->maxGrammi) {
        //printf("Quantita insufficiente per l'ingrediente %s!\n", nodoIngrediente->ingrediente);
        return false; // Non fattibile
    }

    return verificaIngrediente(nodoIngrediente->left, associatedRecipe, ammount) &&
           verificaIngrediente(nodoIngrediente->right, associatedRecipe, ammount);
}


// Funzione principale che calcola la fattibilità
int calcolaFattibilita(Ricetta *associatedRecipe, int ammount) {
    // Inizializza l'iterazione dall'albero degli ingredienti
    return verificaIngrediente(associatedRecipe->root, associatedRecipe, ammount) ? 0 : 1;
}

// Funzione per creare un nuovo ordine
Ordine *creaNuovoOrdine(const char *nome_ricetta, const int ammount, Ricetta *associatedRecipe, const int time) {
    // Allocazione dinamica per un nuovo ordine
    Ordine *nuovoOrdine = (Ordine *)malloc(sizeof(Ordine));

    if (nuovoOrdine == NULL) {
        // Gestione errore: impossibile allocare memoria
        return NULL;
    }

    // Inizializzazione dei campi
    nuovoOrdine->nome = strdup(nome_ricetta);  // Duplica la stringa, allocando nuova memoria
    nuovoOrdine->ammount = ammount;
    nuovoOrdine->peso = calcolaPeso(associatedRecipe) * ammount;
    nuovoOrdine->status = calcolaFattibilita(associatedRecipe, ammount);; // Stato iniziale
    nuovoOrdine->arrivalTime = time;

    return nuovoOrdine;
}

// Funzione ricorsiva per consumare lotti in ordine di scadenza
void consumaLottiPerScadenza(Lotto *nodoLotto, int *grammiRichiesti, int *maxGrammi) {
    if (nodoLotto == NULL || *grammiRichiesti == 0) {
        return;
    }

    // Chiamata ricorsiva per il sotto albero sinistro (scadenza minore)
    consumaLottiPerScadenza(nodoLotto->left, grammiRichiesti, maxGrammi);

    // Consuma dal lotto corrente
    if (*grammiRichiesti <= nodoLotto->ammount) {
        nodoLotto->ammount -= *grammiRichiesti;
        *maxGrammi -= *grammiRichiesti;
        *grammiRichiesti = 0;
    } else {
        *grammiRichiesti -= nodoLotto->ammount;
        *maxGrammi -= nodoLotto->ammount;
        nodoLotto->ammount = 0;
    }

    // Chiamata ricorsiva per il sotto albero destro (scadenza maggiore)
    consumaLottiPerScadenza(nodoLotto->right, grammiRichiesti, maxGrammi);
}

// Funzione ricorsiva per preparare l'ordine
void preparaOrdineRecursiva(const IngredientNode *nodoCorrente, const Ordine *nuovoOrdine) {
    if (nodoCorrente == NULL) {
        return;
    }

    // Chiamata ricorsiva per il sotto albero sinistro
    preparaOrdineRecursiva(nodoCorrente->left, nuovoOrdine);

    // Trova l'ingrediente nel magazzino utilizzando l'albero rosso-nero
    ResourceNode *ingredienteMagazzino = searchIngredientMagazzino(magazzino.ingredienti, nodoCorrente->ingrediente);

    if (ingredienteMagazzino == NULL) {
        printf("Errore: ricetta fattibile non ha un ingrediente");
        abort();
    }

    // Calcola la quantità richiesta per l'ordine
    int grammiRichiesti = nodoCorrente->quantita * nuovoOrdine->ammount;

    // Consuma lotti in ordine di scadenza
    consumaLottiPerScadenza(ingredienteMagazzino->lotti, &grammiRichiesti, &ingredienteMagazzino->maxGrammi);

    if (grammiRichiesti > 0) {
       printf("Errore: grave ricetta non preparata per intero");
       abort();
    }

    // Chiamata ricorsiva per il sotto albero destro
    preparaOrdineRecursiva(nodoCorrente->right, nuovoOrdine);
}

// Funzione principale per preparare l'ordine
void preparaOrdine(Ordine *nuovoOrdine, Ricetta *associatedRecipe) {
    if (nuovoOrdine->status == 1) {
        printf("Errore: grave ordine in preparazione anche se non fattibile");
        abort();
    }

    // Inizia la preparazione dell'ordine dal nodo radice
    preparaOrdineRecursiva(associatedRecipe->root, nuovoOrdine);

    nuovoOrdine->status = 3; // Stato aggiornato: pronto per la spedizione
    ordinazioni.num_ordinazioni_pronte++;
}


int processaOrdiniSospeso(OrderNode *node) {
    int trovato = 0;  // Variabile per memorizzare se un ordine realizzabile è stato trovato

    if (node == NULL) {
        return 0; // Restituisce 0 se il nodo è nullo
    }

    // Visita del sottoalbero sinistro (più piccolo arrivalTime)
    trovato |= processaOrdiniSospeso(node->left);

    // Ricontrolla la fattibilità dell'ordine
    if (node->ordine.status == 1) {
        Ricetta *associatedRecipe = searchRicetta(catalogo.root, node->ordine.nome);
        node->ordine.status = calcolaFattibilita(associatedRecipe, node->ordine.ammount);
        if (node->ordine.status == 1) {
            trovato = 1; // Segnala che è stato trovato un ordine con fattibilità ricalcolata = 1
        } else if (node->ordine.status == 0) {
            preparaOrdine(&node->ordine, associatedRecipe);
        }
    }

    // Visita del sottoalbero destro (più grande arrivalTime)
    trovato |= processaOrdiniSospeso(node->right);

    return trovato; // Restituisce 1 se è stato trovato almeno un ordine con fattibilità ricalcolata = 1, altrimenti 0
}





//=============================FUNZIONI=DI=STAMPA=TESTING==================================

// Funzione per fare una traversata in ordine dell'albero degli ingredienti
void inOrderIngredientTraversal(const IngredientNode *root) {
    if (root != NULL) {
        inOrderIngredientTraversal(root->left);
        printf("    - %s: %d\n", root->ingrediente, root->quantita);
        inOrderIngredientTraversal(root->right);
    }
}

// Funzione per fare una traversata in ordine dell'albero delle ricette
void inOrderRecipeTraversal(const RecipeNode *root) {
    if (root != NULL) {
        inOrderRecipeTraversal(root->left);

        // Stampa il nome della ricetta
        printf("Ricetta: %s (%d Ord sospesi)\n", root->ricetta->nome, root->ricetta->activeOrders);
        printf("Ingredienti:\n");

        // Stampa gli ingredienti della ricetta
        inOrderIngredientTraversal(root->ricetta->root);
        printf("\n");

        inOrderRecipeTraversal(root->right);
    }
}

// Funzione per stampare tutte le ricette nel catalogo
void printCatalogo(const Catalogo *catalogo) {

    printf("\n\n>CATALOGO (%d recipes)<\n",catalogo->num_ricette);

    if (catalogo->root != NULL) {
        inOrderRecipeTraversal(catalogo->root);
    } else {
        printf("Il catalogo è vuoto.\n");
    }
}

// Funzione per stampare tutti i lotti di un ingrediente
void stampaLotti(const Lotto *lotto) {
    if (lotto == NULL) {
        return;
    }

    // Traversata in-order dell'albero dei lotti
    stampaLotti(lotto->left);
    printf("  Lotto - Quantita: %d grammi, Scadenza: %d\n", lotto->ammount, lotto->scadenza);
    stampaLotti(lotto->right);
}

// Funzione per stampare gli ingredienti con i loro relativi lotti
void stampaIngredienti(ResourceNode *nodo) {
    if (nodo == NULL) {
        return;
    }

    // Traversata in-order dell'albero degli ingredienti
    stampaIngredienti(nodo->left);
    printf("Ingrediente: %s\n", nodo->nome);
    printf("  Totale: %d grammi, Numero di lotti: %d\n", nodo->maxGrammi, nodo->num_lotti);

    // Stampa dei lotti per l'ingrediente corrente
    stampaLotti(nodo->lotti);

    stampaIngredienti(nodo->right);
}

// Funzione principale per stampare tutti gli ingredienti nel magazzino
void stampaMagazzino(const Magazzino *magazzino) {

    if (magazzino == NULL || magazzino->ingredienti == NULL) {
        printf("Il magazzino è vuoto.\n");
        return;
    }

    printf("\n\n>MAGAZZINO (%d ingredients)<\n",magazzino->num_ingredienti);

    stampaIngredienti(magazzino->ingredienti);
}

// Funzione ricorsiva per stampare l'albero
void printOrderNode(const OrderNode *node) {
    if (node == NULL) {
        return;
    }

    // Visita del sottoalbero sinistro
    printOrderNode(node->left);

    // Stampa del nodo corrente
    printf("Nome Ordine: %s\n", node->ordine.nome);
    printf("Quantita: %d\n", node->ordine.ammount);
    printf("Peso: %d\n", node->ordine.peso);
    printf("Status: %d\n", node->ordine.status);
    printf("Tempo di Arrivo: %d\n", node->ordine.arrivalTime);
    printf("----------------------------\n");

    // Visita del sottoalbero destro
    printOrderNode(node->right);
}

// Funzione principale per stampare tutte le ordinazioni
void printOrdinazioni(Ordinazioni *ordinazioni) {
    if (ordinazioni->ordinazioni == NULL) {
        printf("Nessuna ordinazione disponibile.\n");
        return;
    }
    printf("\n\n>Ordinazioni (%d ordini)<\n",ordinazioni->num_ordinazioni_pronte);
    printOrderNode(ordinazioni->ordinazioni);
}

void stampaOrdini(Ordine* ordiniCaricare, int numPacchi) {
    for (int i = 0; i < numPacchi; i++) {
        //printf(" %d %s %d\n", ordiniCaricare[i].arrivalTime,ordiniCaricare[i].nome,ordiniCaricare[i].ammount);

        char buffer[256]; // Assicurati che sia abbastanza grande per contenere tutta la stringa
        sprintf(buffer, "%d %s %d\n", ordiniCaricare[i].arrivalTime, ordiniCaricare[i].nome, ordiniCaricare[i].ammount);
        //printf("ordine: %d", i );
        fputs(buffer, file2);

    }
}

//=========================================CORRIERE=====================================================================

int confrontaOrdiniPerPeso(const void *a, const void *b) {
    const Ordine *ordineA = (const Ordine *)a;
    const Ordine *ordineB = (const Ordine *)b;

    // Ordinamento per peso crescente
    if(ordineB->peso!=ordineA->peso) {
        return ordineB->peso - ordineA->peso;
    } else {
        return ordineA->arrivalTime - ordineB->arrivalTime;
    }

}

// Funzione per ordinare l'array di ordini per peso
void ordinaOrdiniPerPeso(Ordine *ordini, int numOrdini) {
    qsort(ordini, numOrdini, sizeof(Ordine), confrontaOrdiniPerPeso);
}

void raccogliOrdini(OrderNode *root, OrdineConNodo **ordiniTemp, int *numOrdini) {
    if (root == NULL) {
        return;
    }

    // Visita il sottoalbero sinistro
    raccogliOrdini(root->left, ordiniTemp, numOrdini);

    // Processa il nodo corrente
    if (root->ordine.status == 3) { // Solo gli ordini pronti per la spedizione
        *ordiniTemp = (OrdineConNodo*)realloc(*ordiniTemp, (*numOrdini + 1) * sizeof(OrdineConNodo));
        if (*ordiniTemp == NULL) {
            perror("Errore realloc");
            exit(1);
        }
        (*ordiniTemp)[*numOrdini].ordine = root->ordine;
        (*ordiniTemp)[*numOrdini].nodoAlbero = root;  // Salva il puntatore al nodo
        (*numOrdini)++;
    }

    // Visita il sottoalbero destro
    raccogliOrdini(root->right, ordiniTemp, numOrdini);
}


void caricaOrdiniSuCorriere(OrderNode *root, Ordinazioni *ordiniDaSpedire, Corriere *corriere) {
    OrdineConNodo *ordiniTemp = NULL;
    int numOrdini = 0;

    // Raccoglie tutti gli ordini dall'albero
    raccogliOrdini(root, &ordiniTemp, &numOrdini);

    Ordine *ordiniCaricare = NULL;
    int numPacchi = 0;

    for (int i = 0; i <numOrdini; i++) {
        if ((corriere->caricoParziale + ordiniTemp[i].ordine.peso) > corriere->caricoMax) {
            break;
        }

        // Aggiorna lo stato dell'ordine nel nodo dell'albero
        ordiniTemp[i].nodoAlbero->ordine.status = 4;  // Cambia lo stato dell'ordine a "spedito"

        // Alloca spazio per un nuovo ordine
        ordiniCaricare = (Ordine*)realloc(ordiniCaricare, (numPacchi + 1) * sizeof(Ordine));

        // Inserisce l'ordine nell'array finale
        ordiniCaricare[numPacchi] = ordiniTemp[i].ordine;
        numPacchi++;

        // Aumenta il carico del corriere
        corriere->caricoParziale += ordiniTemp[i].ordine.peso;

        //Aggiorna ordini in sospeso
        searchRicetta(catalogo.root,ordiniTemp[i].ordine.nome)->activeOrders--;
        ordinazioni.num_ordinazioni_pronte--;
    }

    // Stampa gli ordini caricati
    if (ordiniCaricare == NULL) {
        //printf("camioncino vuoto\n");
        fputs("camioncino vuoto\n",file2);
    } else {

       // char buffer[256]; // Assicurati che sia abbastanza grande per contenere tutta la stringa
       // sprintf(buffer, "time : %d\n", time); // Correzione: rimosse le parentesi
       // fputs(buffer, file2); // Scrivi il contenuto del buffer nel file TODO TESING

        ordinaOrdiniPerPeso(ordiniCaricare, numPacchi);
        stampaOrdini(ordiniCaricare, numPacchi);
    }

    // Libera la memoria temporanea
    if (ordiniTemp != NULL) {
        free(ordiniTemp);
    }
    if (ordiniCaricare != NULL) {
        free(ordiniCaricare);
    }

    // Rimuovi gli ordini caricati dal magazzino
    corriere->caricoParziale = 0;
    rimuoviOrdini(&ordinazioni);
}

//=========================================INPUT========================================================================
// Funzione per processare l'input
void processInput(const char *input) {
    char *input_copy = strdup(input); // Copia dell'input originale
    char *input_copy2 = strdup(input_copy);
    char *token = strtok(input_copy, " ");

    //comando non valido
    if ((strcmp(token, "aggiungi_ricetta") != 0) &&
        (strcmp(token, "rimuovi_ricetta") != 0) &&
        (strcmp(token, "rifornimento") != 0) &&
        (strcmp(token, "ordine") != 0)) {
        printf("time: %d -> Comando non riconosciuto! (>%s<)\n", time, token);
        free(input_copy);
        free(input_copy2);
        return;  // Usa return invece di abort per assicurarti di liberare memoria
    }

    // Testing
    printf("time: %d -> %s\n", time, token);

    // Identifica il comando (4 comandi)
    if (strcmp(token, "aggiungi_ricetta") == 0) {
        // Recupera il nome della ricetta
        const char *nome_ricetta = strtok(NULL, " ");

        // Verifica ricetta già esistente
        if (searchRicetta(catalogo.root, nome_ricetta) != NULL) {  // Usa NULL per puntatori
            //printf("ignorato\n");
            fputs("ignorato\n",file2);
            free(input_copy);
            free(input_copy2);
            return;
        }

        // Conta il numero di ingredienti e quantità
        int num_ingredienti = 0;
        char *nome_ingrediente = NULL;
        char *ammount_str = NULL;

        // Itera attraverso il resto della stringa per ottenere gli ingredienti
        while ((nome_ingrediente = strtok(NULL, " ")) != NULL &&
               (ammount_str = strtok(NULL, " ")) != NULL) {
            num_ingredienti++;
        }

        // Creazione di una nuova ricetta
        Ricetta *nuovaRicetta = malloc(sizeof(Ricetta)); // Allocazione dinamica della ricetta

        if (nuovaRicetta == NULL) {
            // Gestisci errore di allocazione
            printf("Errore di allocazione della memoria per la ricetta\n");
            free(input_copy);
            free(input_copy2);
            return;
        }
        nuovaRicetta->nome = strdup(nome_ricetta);  // Copia del nome della ricetta
        nuovaRicetta->root = NULL; // Inizializza la radice degli ingredienti
        nuovaRicetta->num_ingredienti = num_ingredienti;
        nuovaRicetta->activeOrders = 0;

        // Resetta `strtok` per rileggere gli ingredienti e quantità
        strtok(input_copy2, " ");  // Resetta strtok sulla copia
        strtok(NULL, " ");         // Salta il nome della ricetta

        // Aggiungi gli ingredienti alla ricetta
        for (int i = 0; i < num_ingredienti; i++) {
            nome_ingrediente = strtok(NULL, " ");
            ammount_str = strtok(NULL, " ");
            int ammount = atoi(ammount_str);

            // Aggiungi l'ingrediente alla ricetta
            insertIngredient(nuovaRicetta, nome_ingrediente, ammount);
        }

        // Aggiunta ricetta al ricettario
        insertRicetta(&catalogo.root, nuovaRicetta);
        //printf("aggiunta\n");
        fputs("aggiunta\n",file2);

        // Libera memoria temporanea
        free(input_copy);
        free(input_copy2);
        return;
    }


    if (strcmp(token, "rimuovi_ricetta") == 0) {
        // Recupera il nome della ricetta
        const char *nome_ricetta = strtok(NULL, " ");

        Ricetta *recipeToKill = searchRicetta(catalogo.root, nome_ricetta);

        if(recipeToKill==NULL)
        {
           //printf("non presente\n");
            fputs("non presente\n",file2);

           free(input_copy);
           return;
        }

        if(recipeToKill->activeOrders!=0){
           //printf("ordini in sospeso\n");
           fputs("ordini in sospeso\n",file2);
           free(input_copy);
           return;
        }

        rimuoviRicetta(recipeToKill);

        free(input_copy);
        //printf("rimossa\n");
        fputs("rimossa\n",file2);
        return;
    }

    if (strcmp(token, "rifornimento") == 0) {

    // Conta il numero di lotti da immagazzinare
    int num_lotti = 0;
    char *lotto_ingrediente = NULL;
    const char *ammount_str = NULL;
    const char *scadenza_str = NULL;

    // Itera attraverso il resto della stringa per ottenere il numero dei nuovi lotti da immagazzinare
    while ((lotto_ingrediente = strtok(NULL, " ")) != NULL && (ammount_str = strtok(NULL, " ")) != NULL && (scadenza_str = strtok(NULL, " ")) != NULL) {
        num_lotti++;
    }

    strtok(input_copy2, " ");  // Resetta strtok sulla copia

    for (int i = 0; i < num_lotti; i++) {
        lotto_ingrediente = strtok(NULL, " ");
        ammount_str = strtok(NULL, " ");
        scadenza_str = strtok(NULL, " ");
        int ammount = atoi(ammount_str);
        int scadenza = atoi(scadenza_str);

        if(scadenza>time) {
            // Aggiungi i nuovi lotti al magazzino
           aggiungiIngredienteMagazzino(&magazzino,lotto_ingrediente, ammount, scadenza);
        }
    }
        free(input_copy);
        free(input_copy2);
        //printf("rifornito\n");
        fputs("rifornito\n",file2);

        processaOrdiniSospeso(ordinazioni.ordinazioni);

        return;
    }

    if (strcmp(token, "ordine") == 0) {
        // Recupera il nome della ricetta associata all'ordine
        char *nome_ricetta = strtok(NULL, " ");

        if(strcmp(nome_ricetta, "7DdVF1Z0tLds") == 0) {
            printf("Ricetta\n");
        }

        Ricetta *associatedRecipe = searchRicetta(catalogo.root, nome_ricetta);

        if (associatedRecipe == NULL) {
            //printf("rifiutato\n");
            fputs("rifiutato\n",file2);
        } else {
            //printf("accettato\n");
            fputs("accettato\n",file2);
            const int ammount = atoi(strtok(NULL, " "));
            Ordine *nuovoOrdine = creaNuovoOrdine(nome_ricetta, ammount, associatedRecipe, time);
            if(nuovoOrdine->status==0) {
                preparaOrdine(nuovoOrdine, associatedRecipe);
            }
            insertOrder(&(ordinazioni.ordinazioni), *nuovoOrdine);
            associatedRecipe->activeOrders++;

            // Libera la memoria allocata per `nuovoOrdine`
            free(nuovoOrdine);
        }

        // Libera la memoria allocata per `input_copy`
        free(input_copy);
        return;
    }


}


int main() {

    char buffer[BUFFER_SIZE];
    FILE *file = fopen("open10.txt", "r");
    if (file == NULL) {
        perror("Errore nell'apertura del file");
        return EXIT_FAILURE;
    }



    // Apri il file in modalità scrittura
    file2 = fopen("TestOut.txt", "w");
    if (file2 == NULL) {
        printf("Errore nell'apertura del file!\n");
        return 1;
    }



    int timeSpedizioni = 0;

     // Lettura della prima riga
    if (fgets(buffer, sizeof(buffer), file) != NULL) {
        const size_t len = strlen(buffer);
        if (len > 0 && buffer[len - 1] == '\n') {
            buffer[len - 1] = '\0';
        }

        corriere.timeCorriere = atoi(strtok(buffer, " "));
        corriere.caricoMax = atoi(strtok(NULL, " "));

        corriere.caricoParziale = 0;

        timeSpedizioni = corriere.timeCorriere;
    }

    // Processa le righe rimanenti
    while (fgets(buffer, sizeof(buffer), file) != NULL) {
        const size_t len = strlen(buffer);
        if (len > 0 && buffer[len - 1] == '\n') {
            buffer[len - 1] = '\0';
        }

        if (time % timeSpedizioni == 0 && time != 0) {
            // processa il corriere
            caricaOrdiniSuCorriere(ordinazioni.ordinazioni, &ordinazioni, &corriere);
        }

        //printf("Verifico la scadenza di tutti gli ingredienti)
        verificaScadenza(magazzino.ingredienti,time);
        verificaQuantita(magazzino.ingredienti);

        // Processa input
        processInput(buffer);

        time++;
    }

    verificaScadenza(magazzino.ingredienti,time);
    verificaQuantita(magazzino.ingredienti);

    if (time % timeSpedizioni == 0 && time != 0) {
        // processa il corriere
        caricaOrdiniSuCorriere(ordinazioni.ordinazioni, &ordinazioni, &corriere);
    }

    // Chiusura del file di output
    fclose(file);

    // Stampa in ordine del ricettario

    //printCatalogo(&catalogo);
    //stampaMagazzino(&magazzino);

    //Stampa tutte le ordinazioni
    //printOrdinazioni(&ordinazioni);

    fclose(file);

    return 0;
}

